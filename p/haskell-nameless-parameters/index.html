<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>AtnNn.com - Writing Haskell Functions With Many Nameless Parameters</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">Etienne Laurin</a>
            </div>
            <div id="navigation">
              <a href="https://twitch.tv/choongmoo" class="stream-status">
                <span class="stream-online">Live Now</span>
                <span class="stream-offline">Off Air</span>
              </a>
              <a href="../../about">About</a>
            </div>
        </div>
        <div id="content">
            <h1>Writing Haskell Functions With Many Nameless Parameters</h1>

            <div class="info">
    Posted on October  3, 2011
    
</div>

<p>Although it could be considered bad style, it is often useful to have functions that take a large amount of similar parameters that vary in type. I am going to demonstrate a technique that allows to write such functions without naming these parameters and making the function more readable.</p>
<p>The function I will use for demonstration is an example of a common pattern when working with JSON data.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UnicodeSyntax, OverloadedStrings #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson.Types</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>person ∷ <span class="dt">String</span> → <span class="dt">Float</span> → <span class="dt">Bool</span> → <span class="dt">Value</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>person name height over18 <span class="ot">=</span> object [</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;name&quot;</span> <span class="op">.=</span> name,</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;height&quot;</span> <span class="op">.=</span> height,</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;over18&quot;</span> <span class="op">.=</span> over18]</span></code></pre></div>
<p>The name of each parameter is repeated three times. Writing many such functions is often done by copying and pasting, which is a red flag and a possible source of errors.</p>
<p>In an attempt to write reusable code, we can define a simple function that builds the result in small steps.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>field ∷ <span class="dt">ToJSON</span> a ⇒ <span class="dt">Text</span> → [<span class="dt">Pair</span>] → a → [<span class="dt">Pair</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>field k d v <span class="ot">=</span>  (k, toJSON v) <span class="op">:</span> d</span></code></pre></div>
<p>The order of the arguments is important because it fits well into the <code>$-</code> combinator. This combinator is the key to the whole exercise. It builds our desired multi-argument function without having to name the arguments.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">3</span> <span class="op">$-</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">$-</span>) ∷ (d → a → e) → (e → k) → d → a → k</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>(<span class="op">$-</span>) f g d a <span class="ot">=</span> g <span class="op">$</span> f d a</span></code></pre></div>
<p>(Some readers may recognise this relative of the infamous cartoon face operator <code>((.).(.))</code>)</p>
<p>We can now rewrite the person function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>person' ∷ <span class="dt">String</span> → <span class="dt">Float</span> → <span class="dt">Bool</span> → <span class="dt">Value</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>person' <span class="ot">=</span> (<span class="op">$</span>[])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span>  field <span class="st">&quot;name&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">$-</span> field <span class="st">&quot;height&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">$-</span> field <span class="st">&quot;over18&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">$-</span> object</span></code></pre></div>
<p>The first part of the function body, <code>($[])</code>, is the initial value used to build our object. The last part, <code>$- object</code> transforms the list that was built incrementally into the final result.</p>
<p>This technique becomes more powerful when you write other helper functions. For example, we can also have another function that ignores <code>Nothing</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>optfield ∷ <span class="dt">ToJSON</span> a ⇒ <span class="dt">Text</span> → [<span class="dt">Pair</span>] → <span class="dt">Maybe</span> a → [<span class="dt">Pair</span>]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>optfield k d (<span class="dt">Just</span> v) <span class="ot">=</span> field k d v</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>optfield _ d <span class="dt">Nothing</span> <span class="ot">=</span> d</span></code></pre></div>
<p>The <code>$-</code> combinator’s usefulness is not limited to building JSON objects. It can be used to write many functions that need to combine heterogeneous values for which simple utility functions such as field and optfield can be written. Functions written in this style make cleaner, less repetitive code.</p>

        </div>
        <div id="footer">
          © 2010-2020 Etienne Laurin
        </div>
    </body>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-11375946-4', 'auto');
  ga('send', 'pageview');
</script>
<script src="//code.jquery.com/jquery-1.11.2.min.js"></script>
<script>
function checkTwitch(){
  $.ajax({
  url: 'https://api.twitch.tv/kraken/streams/choongmoo',
  dataType: "json",
  headers: {"Client-ID": "mznbgisvte41vmhkavwixj9g8sdosta"},
  success: function(c){
    console.log("channel info", c);
    if (c["stream"]!=null){
      $('.stream-status').addClass('online');
    }else{
      $('.stream-status').removeClass('online');
    }}});
}
checkTwitch();
setInterval(checkTwitch, 2 * 60 * 1000);
</script>
</html>
